---
title: What's so good about Rust, anyways?
...

# What's so good about Rust, anyways?

Someone asked me this question a few weeks ago, and it occurred to me that when
people extoll the virtues of Rust, they usually talk about things like memory
safety and the borrow checker.

That's neat and all for people coming from C or C++, but for anyone coming from
a GC'd language like Go or Java or Python or Typescript, well, those aren't
problems they have.

Rust has plenty going for it, though, besides the memory safety and borrow checker,
and those other features are why I actually like using Rust - and as a community, I
don't think we talk enough about all those other language features.

So let's talk about my favorite Rust features!:

- null safety
- exhaustive match statements
- enums are powerful
- value destructuring
- exceptions do not bypass normal control flow
- built-in JSON serialization
- clone gets you deep clone
- compiler has some really nice type narrowing capabilities
- everything is an expression
- the library ecosystem is pretty fantastic

## Null safety

If you've ever spent time with a mainstream programming language, you've had
code blow up in your face because you didn't check that something was null.

  - C++: your program will irrecoverably blow up in your face if you pass a 
  `nullptr` to something that accepts only non-null pointers,
  like `printf` (yay for segfaults! said no one ever)

    ```
    ❯ clang++ foo.cc && ./a.out
    [1]    32957 segmentation fault  ./a.out
    ```

  
  - Go: pass a `nil` somewhere it doesn't belong? Have fun debugging!

    ```
    panic: runtime error: invalid memory address or nil pointer dereference
    [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x48ebfa]

    goroutine 1 [running]:
    main.main()
      /tmp/sandbox4269208483/prog.go:21 +0x1a

    Program exited.
    ```

  - Java: almost anything is allowed to be `null`, and if you forget to check if it's null before using it, voila, the runtime will just throw a `NullPointerException`.  You can
  even pass `null` into a method that expects an `Optional<String>`!

    ```
    Exception in thread "main" java.lang.NullPointerException: Cannot invoke "String.length()" because "<local1>" is null
        at Foo.main(Foo.java:4)
    ```

  - JS/TS: you have both `undefined` and `null`, both of which will happily trigger a `TypeError` if you use them somewhere you didn't expect to have to handle either. (We're not going to talk about the maddeningly subtle differences between the two.)

    ```
    Uncaught TypeError: Cannot read properties of undefined (reading 'length')
    Uncaught TypeError: Cannot read properties of null (reading 'length')
    ```


  - Python: if you forget to check if `value is None`, the runtime will throw a `TypeError` yelling something about how your `NoneType` object is missing methods.

    ```
    Traceback (most recent call last):
      File "<string>", line 1, in <module>
    TypeError: object of type 'NoneType' has no len()
    ```

All of these errors are possible because all of these languages allow most objects to be `null`, and rely on the user to make sure that they're checking if something is null before using it. If you have an object that you pass around which used to never be `null`, but now is `null` sometimes, well... good luck - that gets hairy really fast.

In Rust's type system, by contrast, you can only pass `None` into functions that accept `Option<Foo>` - the compiler will explicitly reject an attempt to pass `None` into - so it's impossible for a Rust program to fail at runtime because you didn't realize something could be `None`.


 “Null References: The Billion Dollar Mistake,” Tony Hoare, the inventor of null
 https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values

## switch statements are exhaustive

rust compiler can enforce that your switch statements are exhaustive

in c++, you need to turn on `-Werror` for this

java has... nothing

ts has this

python: you have to figure out how to set this up in your type-checker (since the language can't do this for you)
- pyright: go and find the pyright setting to turn this on
- mypy: figure out how to run with mypy
- pytype: sorry, i don't know who else uses this besides google

## enums are powerful

in most languages, your enum looks something like this:

```
enum Color = { Red, Green, Blue }
```

rust allows you to include more structure in your enums:

```
  enum IpAddr {
      V4(u8, u8, u8, u8),
      V6(String),
  }
  ```

to do the same in the other languages:

- in ts, you usually do something like `type IpAddr = { kind: "v4", nums: number[] } | {kind: "v6", addr: string}`
- you cannot express this in java. you certainly can't get the compiler to type-check it. what you can do in java is

```
class Foo {
  Color color;
  RedProperties redProps;  // only meaningful if color == Red
  BlueProps blueProps;     // only meaningful if color == Blue
  GreenProps greenProps;   // only meaningful if color == Green
}
```

and you get no compiler guarantees about what goes into `greenProps` when `color == Red`

## value destructuring

ts has had this for a long time

c++ has structured bindings, which kinda looks like this but only supports statically-sized arrays and tuples, not structs

python destructuring has all sorts of footguns:

- `ValueError: not enough values to unpack (expected 4, got 3)`

```
my_dict = {"name": "Bob", "age": 25}
x, y = my_dict
```

is equivalent to `(x, y) = ("name", "age")`. obvious if you understand why, but try explaining this when you're teaching python to someone.

specifically, rust allows you to write code like this:

```
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

which you would handle like this:

```
match message {
  Quit => {
    println!("quit!");
  }
  Move { x, y } => {
    println!("move to ({x}, {y})");
  }
  Write(w) => {
    println!("write this down: {w}")
  }
  ChangeColor(r, g, b) => {
    println!("change color to this RGB: ({r}, {g}, {b})")
  }
}
```

and this is all tied into the 

## exceptions do not bypass normal control flow

let's say you try to read a file, but someone saved it with the wrong permissions

in python, c++, java, ts, this will cause some kind of error that will propagate
all the way up the callstack, with no static hint or compiler hint that this
might happen deeper in your call stack and you should probably handle it

this usually takes the form of:

```
doThingWithLibrary()
```

"why is this code crashing?"

"oh, because `doThingWithLibrary()` can throw `FileNotFoundException`... ok, i should handle that"

and then if you get paranoid about handling it, you end up adding `try { ... }
catch (FileNotFoundException e) { ... }` at three different layers of the
callstack, even though you only actually need 1 of them, because your tooling
has no way to tell you which one of those is actually necessary

this ends up being the same reason we no longer use `goto` statements in our code, and is also the reason that golang did away with the notion of exceptions

(OK, technically, panics are exceptions in Rust. but most APIs that can fail
require the user to handle this _explicitly_ using `Result<Ok, Error>` which
requires the user to handle the `Ok` and `Error` variants explicitly. if the
user wants to just panic? sure, have fun! but most rust users would consider it
bad practice to `unwrap()` your way to working code)

and there is `?` to ergonomically handle dealing with `Error` variants, which allows doing stuff like

```
let latin = foo.bar()?.fizz()?.buzz()?;
process(latin)
```

compare this with the golang equivalent:

```
latin, err := foo.Bar()
if err != nil {
    return err
}

latin, err = latin.Fizz()
if err != nil {
    return err
}

latin, err = latin.Buzz()
if err != nil {
    return err
}

process(latin)
```

## everything is an expression

really nice for switch expressions. weirder for if-else, but it grows on you, certainly ebtter than python's confusing `value if condition else else-value`
 
 or TS needing anonymous functions if you want a switch statement

this one takes a little while to get used to, but it grows on you after a while

## built-in json serialization

OK, maybe it's not _quite_ built into the Rust standard library, but `serde` and `serde_json` make it _really_ easy to serialize and deserialize JSON into a statically typed object

example:

```
#[derive(Deserialize, Serialize)]
struct Repository {
  default_branch: String,
  open_issues: i32,
  topics: Vec<String>,
  has_issues: bool,
}
```

is all the code you need to parse this json object:

```json
{
  "default_branch": "main",
  "open_issues_count": 0,
  "open_issues": 0,
  "topics": [ "octocat", "api", ],
  "has_issues": true,
}
```

there's no standard way to do this in C++ or java (not without some kind of
codegen); in TS you have zod for this but the type system doesn't allow
communicating guarantees about whether `open_issues` is an integer or float, and in Python you have pydantic, which relies on shenanigans with class variables to type its member variables (explain this)


## clone gets you deep clone

most languages have some manner of implicit copy semantics that come with "shoot yourself in the foot" implications, because if you make a copy, you make a _shallow_ copy, not a deep clone

in rust, `[#derive(Clone)] struct Foo { ... }` means that `foo.clone()` creates a deep copy of the object.

by comparison, in js you need to pull in lodash's structuredClone

in java, c++, you need to implement it yourself. if you don't want to write a few hundred lines of boilerplate, you need to rely on libraries with their own quirks (hello, autovalue) or terrifying template magic in c++'s case


## compiler has some type narrowing capabilities

e.g. the let-else construct:

```
let Ok(read) = std::fs::read("path/to/file.txt") else {
  return Err(MyCustomError("couldn't read file"));
}

process(read)
```

## no inheritance surprises

in c++, multiple inheritance and virtual methods make it really hard to actually
know, for a given `foo.call_method()`, to know which implementation of
`call_method()` is actually getting called

java is slightly easier because everything is a virtual call, but can still be confusing (which, when i was
going back and forth between java and cpp, i was constantly getting confused
about, because i hadn't really internalized this)

python has multiple inheritance

ts inheritance means "don't do wacky shit with prototypes" because, well, you
don't want to find out what happens if you do. (i've actually never tried. i
wonder what you blow up when you do this. all i know is i've heard people say
it's a bad idea.)

because rust doesn't have inheritance, well, in theory it's easy to figure out what 

## backtraces

users of gc'd languages will laugh at this, but for folks coming from c++ this
is actually incredibly painful to set up.

you can use stuff like abseil's debugging, boost's stacktrace, or libunwind, but
you still need to hook into the global exception handlers to do this


## the library ecosystem is pretty fantastic

some of my favorite crates:

- `notify`: cross-platform filesystem watcher
- `etcetera`: makes it easy to store application state in `~/.config/my-app/` in a cross-platform way


## there are still warts

that all being said, rust, like any other language, comes with its own baggage:

- i have to spend a lot of mental energy reasoning about lifetime/ownership semantics,
because of the borrow checker, even when i don't want to. in most cases, i
actually really don't care about lifetime semantics, and would be much happier
with the implicit refcount/GC semantics of a language like Java, TS/Node,
Golang, etc. (also, Arc is the world's worst GC, so performance honestly kinda
strikes me as a... not great argument.) incidentally, this is why i find something like borgo super cool

- so much mental energy, enough that i'm going to devote two bullets to it. you have to get your design right the first time; if you need to refactor it, it is _hard_ to do so. doing quick and dirty prototypes requires a lot of "explicitly bupass the safety" code. going back to the earlier example? if you're not returning a `Result`, that becomes

```
foo.bar().unwrap().fizz().unwrap().buzz().unwrap()
```

and that's just one bit of it.

https://loglog.games/blog/leaving-rust-gamedev/#procedural-macros-are-not-even-we-have-reflection-at-home goes into a lot more depth into all the problems this causes in practice

- async stuff is extra hard, for the same reasons as above: because rust gives
you all the knobs and is as close to the metal as possible,
async needs funky abstractions like `Pin` (i think of understanding `Pin` like
understanding atomics: in theory i understand what it does, and i can parrot the
docs, but if you actually quiz me on the edge cases and how it behaves i will
make an absolute fool of myself). also lifetimes get _way_ harder in async code. (this has entertaining results, like the world collectively deciding that the easy way out of this is to use the world's worst garbage collector: `Arc<Mutex<T>>`, i.e. wrapping everything in an atomic-ref-counted pointer and mutex, so that you can guarantee that an object in an async scope will exist until the async scope finishes)

- you can't format macro code like this:

  ```
  json!({
    "foo": {
  "this": "should be easy to format",
    }
  })
  ```

  but because of how rust macros work it's actually really hard to format it

- hygientic macros are actually kinda annoying.

- rust doesn't have function overloading (e.g. defining `foo(String)` and
`foo(i32)` on a struct and relying on ADL to resolve an overload)

- virtual method calls ard hard to pass around: what does it mean for a type to be statically sized?
maybe that's obvious once you understand it, but it's always frustrating when i
wrap a `dyn StreamExt` as `Box<dyn StreamExt>` willy-nilly because that's my
only option for holding onto a stream object. trait objects 

    in axum, you can't do this:

    ```
    match result {
      Ok(_) => (StatusCode::Ok, Json(...)),
      Err(_) => (StatusCode::InternalServerError, Text(...)),
    }
    ```

    because the `match` expression needs to have a consistent type; there's no
    way in rust right now for a `match` to have arms with differing types, even
    if those types obey the same contract

    (not sure if you can use `return` statements inside the match arms to get
    around the fn's return type being `impl Trait`)

- traits mean that you _need_ an IDE to navigate the code at times. i've learned
to navigate a lot of codebases by literally just `grep`ing my way through them,
but it's an order of magnitude harder to do this in rust.

- compile times are certainly an issue; we'll see how the world decides to solve this.

- hot reload doesn't come out of the box, you have to bolt it on. at least in python and js/ts world you have stuff like `next dev` for nextjs, `flask watch` for python, `fastapi dev` for fastapi. in rust you have to `cargo watch -- build`

- `String` vs `&str` vs `&String` (and then all the sister types like `bytes`
and `Path` and `PathBuf`) - having the explicitness is important and valuable,
but it would also be nice if i could just have it work in the simple cases
without having to go through `Cow<str>` and `to_string_lossy()`...

- the lack of literals or anonymous types is a pain point.

- passing around lambdas can be weird: `Fn` vs `FnMut` vs `FnOnce`

- thinking about ownership and borrowing is annoying. if i'm iterating over a list, very frequently I don't care about the distinction between `vec![1, 2, 3].into_iter().map(...).collect()` and `vec![1, 2, 3].iter().map(...).collect()`.