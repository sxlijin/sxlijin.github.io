---
title: What's so good about Rust, anyways?
...

# What's so good about Rust, anyways?

A few weeks ago, Rust came up in a conversation and I was asked why I like Rust.
This was coming from someone who spends most of their time in a GC'd language,
so a lot of the classic arguments around memory safety, the borrow checker, and so on
weren't really relevant here.

And honestly, i feel like most posts about rust fall into that problem: they talk about
problems that systems programmers have, but not that all programmers have. and there's so
much amazing stuff that rust does that does _not_ fall under the umbrella of
just memory safety or performance, and i don't think the rust community extolls
those virtues enough to non-rust folks

so let's start listing those out:

- most things cannot be null
- exhaustive match statements
- enums are powerful
- value destructuring
- exceptions do not bypass normal control flow
- built-in JSON serialization
- clone gets you deep clone
- compiler has some really nice type narrowing capabilities
- everything is an expression

## most things cannot be null

in python, everything can be `None`, resulting in TypeError

in java, you can pass `null` in for any object, resulting in a `NullPointerException`. for a true nightmare, you can pass `null` into a method that takes an `Optional<String>` and that's just dandy. (yes, checker framework, but who actually sets that up?)

in C++, you can pass a `nullptr` to anything that accepts a pointer, and depending on the API, this may be acceptable or even encouraged, or a way to trigger a segfault and just blow the entire program up

in js/ts, you have both `undefined` and `null`, and it's such a fun game when you're chasing down a bug because of something you didn't realize was `undefined` or `null` (we won't even talk about the differences between the two)

in Rust's type system, there is no such concept: the only functions that can accept a `None` are those which accept `Option<Foo>` (include example)

## switch statements are exhaustive

rust compiler can enforce that your switch statements are exhaustive

in c++, you need to turn on `-Werror` for this

java has... nothing

ts has this

python: you have to figure out how to set this up in your type-checker (since the language can't do this for you)
- pyright: go and find the pyright setting to turn this on
- mypy: figure out how to run with mypy
- pytype: sorry, i don't know who else uses this besides google

## enums are powerful

in most languages, your enum looks something like this:

```
enum Color = { Red, Green, Blue }
```

rust allows you to include more structure in your enums:

```
  enum IpAddr {
      V4(u8, u8, u8, u8),
      V6(String),
  }
  ```

to do the same in the other languages:

- in ts, you usually do something like `type IpAddr = { kind: "v4", nums: number[] } | {kind: "v6", addr: string}`
- you cannot express this in java. you certainly can't get the compiler to type-check it. what you can do in java is

```
class Foo {
  Color color;
  RedProperties redProps;  // only meaningful if color == Red
  BlueProps blueProps;     // only meaningful if color == Blue
  GreenProps greenProps;   // only meaningful if color == Green
}
```

and you get no compiler guarantees about what goes into `greenProps` when `color == Red`

## value destructuring

ts has had this for a long time

c++ has structured bindings, which kinda looks like this but only supports statically-sized arrays and tuples, not structs

python destructuring has all sorts of footguns:

- `ValueError: not enough values to unpack (expected 4, got 3)`

```
my_dict = {"name": "Bob", "age": 25}
x, y = my_dict
```

is equivalent to `(x, y) = ("name", "age")`. obvious if you understand why, but try explaining this when you're teaching python to someone.

specifically, rust allows you to write code like this:

```
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

which you would handle like this:

```
match message {
  Quit => {
    println!("quit!");
  }
  Move { x, y } => {
    println!("move to ({x}, {y})");
  }
  Write(w) => {
    println!("write this down: {w}")
  }
  ChangeColor(r, g, b) => {
    println!("change color to this RGB: ({r}, {g}, {b})")
  }
}
```

and this is all tied into the 

## exceptions do not bypass normal control flow

let's say you try to read a file, but someone saved it with the wrong permissions

in python, c++, java, ts, this will cause some kind of error that will propagate
all the way up the callstack, with no static hint or compiler hint that this
might happen deeper in your call stack and you should probably handle it

this usually takes the form of:

```
doThingWithLibrary()
```

"why is this code crashing?"

"oh, because `doThingWithLibrary()` can throw `FileNotFoundException`... ok, i should handle that"

and then if you get paranoid about handling it, you end up adding `try { ... }
catch (FileNotFoundException e) { ... }` at three different layers of the
callstack, even though you only actually need 1 of them, because your tooling
has no way to tell you which one of those is actually necessary

this ends up being the same reason we no longer use `goto` statements in our code, and is also the reason that golang did away with the notion of exceptions

(OK, technically, panics are exceptions in Rust. but most APIs that can fail
require the user to handle this _explicitly_ using `Result<Ok, Error>` which
requires the user to handle the `Ok` and `Error` variants explicitly. if the
user wants to just panic? sure, have fun! but most rust users would consider it
bad practice to `unwrap()` your way to working code)

and there is `?` to ergonomically handle dealing with `Error` variants, which allows doing stuff like

```
let latin = foo.bar()?.fizz()?.buzz()?;
process(latin)
```

compare this with the golang equivalent:

```
latin, err := foo.Bar()
if err != nil {
    return err
}

latin, err = latin.Fizz()
if err != nil {
    return err
}

latin, err = latin.Buzz()
if err != nil {
    return err
}

process(latin)
```

## everything is an expression

really nice for switch expressions. weirder for if-else, but it grows on you, certainly ebtter than python's confusing `value if condition else else-value`

this one takes a little while to get used to, but it grows on you after a while

## built-in json serialization

OK, maybe it's not _quite_ built into the Rust standard library, but `serde` and `serde_json` make it _really_ easy to serialize and deserialize JSON into a statically typed object

example:

```
#[derive(Deserialize, Serialize)]
struct Repository {
  default_branch: String,
  open_issues: i32,
  topics: Vec<String>,
  has_issues: bool,
}
```

is all the code you need to parse this json object:

```json
{
  "default_branch": "main",
  "open_issues_count": 0,
  "open_issues": 0,
  "topics": [ "octocat", "api", ],
  "has_issues": true,
}
```

there's no standard way to do this in C++ or java (not without some kind of
codegen); in TS you have zod for this but the type system doesn't allow
communicating guarantees about whether `open_issues` is an integer or float, and in Python you have pydantic, which relies on shenanigans with class variables to type its member variables (explain this)


## clone gets you deep clone

most languages have some manner of implicit copy semantics that come with "shoot yourself in the foot" implications, because if you make a copy, you make a _shallow_ copy, not a deep clone

in rust, `[#derive(Clone)] struct Foo { ... }` means that `foo.clone()` creates a deep copy of the object.

by comparison, in js you need to pull in lodash's structuredClone

in java, c++, you need to implement it yourself. if you don't want to write a few hundred lines of boilerplate, you need to rely on libraries with their own quirks (hello, autovalue) or terrifying template magic in c++'s case


## compiler has some type narrowing capabilities

e.g. the let-else construct:

```
let Ok(read) = std::fs::read("path/to/file.txt") else {
  return Err(MyCustomError("couldn't read file"));
}

process(read)
```

## no inheritance surprises

in c++, multiple inheritance and virtual methods make it really hard to actually
know, for a given `foo.call_method()`, to know which implementation of
`call_method()` is actually getting called

java is slightly easier because everything is a virtual call, but can still be confusing (which, when i was
going back and forth between java and cpp, i was constantly getting confused
about, because i hadn't really internalized this)

python has multiple inheritance

ts inheritance means "don't do wacky shit with prototypes" because, well, you
don't want to find out what happens if you do. (i've actually never tried. i
wonder what you blow up when you do this. all i know is i've heard people say
it's a bad idea.)

because rust doesn't have inheritance, well, in theory it's easy to figure out what 


## there are still warts

that all being said, rust, like any other language, comes with its own baggage:

- i have to spend a lot of mental energy reasoning about lifetime/ownership semantics,
because of the borrow checker, even when i don't want to. in most cases, i
actually really don't care about lifetime semantics, and would be much happier
with the implicit refcount/GC semantics of a language like Java, TS/Node,
Golang, etc. (also, Arc is the world's worst GC, so performance honestly kinda
strikes me as a... not great argument.) incidentally, this is why i find something like borgo super cool

- async stuff is extra hard, for the same reasons as above: because rust gives
you all the knobs and is as close to the metal as possible,
async needs funky abstractions like `Pin` (i think of understanding `Pin` like
understanding atomics: in theory i understand what it does, and i can parrot the
docs, but if you actually quiz me on the edge cases and how it behaves i will
make an absolute fool of myself). also lifetimes get _way_ harder in async code.

- you can't format macro code like this:

  ```
  json!({
    "foo": {
  "this": "should be easy to format",
    }
  })
  ```

  but because of how rust macros work it's actually really hard to format it

- rust doesn't have function overloading (e.g. defining `foo(String)` and
`foo(i32)` on a struct and relying on ADL to resolve an overload)

- virtual method calls ard hard to pass around: what does it mean for a type to be statically sized?
maybe that's obvious once you understand it, but it's always frustrating when i
wrap a `dyn StreamExt` as `Box<dyn StreamExt>` willy-nilly because that's my
only option for holding onto a stream object. trait objects 

    in axum, you can't do this:

    ```
    match result {
      Ok(_) => (StatusCode::Ok, Json(...)),
      Err(_) => (StatusCode::InternalServerError, Text(...)),
    }
    ```

    because the `match` expression needs to have a consistent type; there's no
    way in rust right now for a `match` to have arms with differing types, even
    if those types obey the same contract

    (not sure if you can use `return` statements inside the match arms to get
    around the fn's return type being `impl Trait`)
